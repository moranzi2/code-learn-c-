#define  _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
//引用第一层，做函数的参数（输出型参数）改变形参可以改变形参
// 减少拷贝提高效率（不需要创建形参）   
// //int& a=b;将a作为b的别名；
// 不是指针用不起而是引用性价比更高；
//从语法来说，只是给了一个别名，没有形参实参开空间之类的东西
//1.引用必须初始化
//2.引用不能改变指向，只能永远是同一个人的别名
//3.一个变量可以有多个别名
//引用只能替代指针改变所指向空间的一个性质
//但是不能完全代替指针（不能改变指向）链表，二叉树都无法应用了
int  Swap(int& a, int& b)
{
	int count = 0;
	count++;
	count++;
	return count;//（先拷贝再销毁，返回一个临时变量，返回到寄存器中）
}
int& swap(int& a, int& b)
{
	int count = 1;
	return count;
}
 //返回了count的别名,也是完全取决于栈帧有没有被销毁；
//仍然是野指（因为实际上空间已经不再属于你）
//之后如果再次有人创建栈帧，则这个引用指向的东西未知
//别名实际上和指针（地址）也是绑定着的，只是不可改变形式不同
//结论：不能返回一个临时变量或者局部变量的引用；
//可以返回一个全局变量（出了函数作用域以后不销毁）的引用
//引用做返回值（a）减少拷贝，修改返回值；
void PushBack(struct Node** pphead, int x)
{
	//*pphead=newnode;
}
void PushBack(struct Node*& pphead, int x)
{
	//pphead是plist的别名； 
}
int main()
{
	int x = 0, y = 1;
	printf("%d",swap(x, y));
}
//引用和指针的区别
//1.语法
//引用是别名不会开空间，指针是地址，是一个变量，需要开空间。
//引用必须初始化，指针可以不初始化
//sizeof（引用）以及引用++和指针++。是否需要解引用访问。
// 引用不能改变指向，但是指针可以
//引用相对更安全，没有空引用，不容易出现野引用（返回局部变量引用）
//2.用法和底层
//（从汇编层面看）引用的底层实际上还是指针，会开空间（语法含义和底层背离）
// 
// 
// 
//
int Add(int a, int b)
{
	return a + b;
}
//不是函数，没有分号，括号控制优先级
#define ADD(a,b) (a)+(b)
//宏的缺点：1.语法复杂，坑比较多
//2.无法调试
//3.无法检查类型
//因此，c++出现了内联函数（减少简单多次重复函数栈帧创建）
//跟宏的效果是一样的，直接替换，不进行函数栈帧创建；
inline int add(int a, int b) 
{
	return a + b;
}