#define  _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<iostream>
/// ///////////////////////////
//拷贝构造函数:也是一个构造的重载形式
// 所以你写了拷贝构造就一定要自己也写一个构造函数
//用一个同类型的其他对象构造自己
//传参也会调用拷贝构造函数；

//如果我们不定义，会函生成默认拷贝构造函数；
//会把成员按内存存储按字节序完成拷贝，又叫 值拷贝或者浅拷贝
//浅拷贝有风险，可能崩溃
//如果成员里面有地址，导致两个指针指向同一块空间，析构的时候释放了两次
//而且第一次释放的时候会导致野指针，还可能影响其他数据；

/// 这时候就需要深拷贝；
//就是把指针里面的内容来拷贝，(先开辟空间，然后把指针指向内容转移过来)


//以后函数传参我们尽量也要用引用不要用传值传参，用引用
//要不然还会自己去调拷贝构造，浪费资源
//同时，如果我们不希望修改传进去的值，可以加一个const来权限缩小
class Date
{
	//Date d2(d1)  Date d(d1)  Date d(d1)
	//func(d1)->d1(&d1)
public:
	//强制编译器生成默认构造函数;
	Date() = default;
	Date(int year = 1, int month=5)
	{
		_year = year;
		_month = month;
	}
	Date(const Date& d)
	{
		_year = d._year;
	}//必须传引用，不然会无穷递归
		//如果传的是值，会创建实参，传参，然后就调用拷贝构造；
		//调用拷贝构造需要再传参，就继续拷贝构造，无解了
		//拷贝构造前面最好加const
	int _year ;
	int _month;//缺省值;
};
//6个默认成员函数，构造和析构。拷贝构造，复制重载，取地址重载
//默认构造函数：全缺省，无参的，以及系统自动生成的
//系统自动生成的函数会把底下的类的默认构造函数调用
//如果底下的类没有默认，就会报错；所以一定要自己弄一个全缺省的；

//析构函数：不是对对象本身的销毁，而是对对象中资源的清理
//任何一个变量，除了在堆区的需要我们手动free，其他的都不需要
//main函数中的局部变量满足一个条件，后进先出，后创建的先析构(栈)


//运算符重载
//用operator+函数名
//目的是让自定义类型也能用运算符
//使用方法 cout<<operator==(x,y)<<endl;
//或者cout<<(x==y)<<endl;
//但是在类外使用有一个问题，类的成员一般是private，无法访问
//解决1.在类内使用Getyear函数，
//Getyear（）{return _year}；
//解决2.在类内用operator函数，但是不要写x了，因为有this指针了已经

bool operator==(const Date& x, const Date& y)
{

}
 
int main()
{
	//不能写成Date d1();和函数的声明分不清了！！
	Date d1(2023,6);
	Date d2(d1);

	int a = 0;
	//权限的缩小
	const int& c = a;
	int& b = a;
	b = 5;
	//但是权限大的可以修改权限小的。b和a可以修改c
	//权限放大
	//int& d = c;
	double d = 1.1;
	int i= d;//流程，先产生一个int临时变量（常性）然后给了i
	//上面是类型提升或者类型转换的一个过程
	const int& ri = d;
	//不能写成int& ri=d；权限放大了

}