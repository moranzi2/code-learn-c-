#pragma once
class Date
{
private:
	//声明给缺省值
	int _year=1;
	int _month=2;//默认成员变量是私有
	//成员函数是公有
	int _day=3;//是声明，定义的主要标志是开空间(对象实例化)
public://this指针自身不能被改变
	//实际上Init的第一个参数是Date*  const this也就是这个类；
	void Init(int year, int month, int day);
	Date();
	Date(int year, int month=1, int day=1);

	//默认构造函数有三种。全缺省的，无参的，默认生成的。
	// 当我们写了一个带参的，又初始化了一个Date d1；
	// 那么d1就找不到合适的默认构造函数了；
	// 
	//构造函数是一个默认成员函数，我们不写，编译器就会自己生成
	// 但是编译器默认的什么也不会做
	// 实际上是对内置类型什么也不做(int)，对自定义类型(class)调用他的构造函数
	// 
	// c++11支持在内置类型声明的位置给缺省值；（见上面）
	// 
	//当函数中自己写了构造函数的时候，
	// 如果初始化的那个变量不能匹配现有的构造函数，也会报错；
	//全缺省和空的最好不要同时存在，调用会存在歧义
	//不知道调用的是全缺省还是空的；

	//析构函数完成的是清理资源(destory)开辟的空间free掉
	// 否则就会内存泄露（free动态开辟的）
	//1.类名前面加~，~Date；
	//2.没有参数没有返回值(无重载只有一个)
	//3.如果没有定义那么编译器会生成一个默认的析构函数
	// 默认的跟构造函数差不多，内置类型不处理，自定义类型调用它的析构
	//4.对象生命周期结束会自动调用；局部-函数结束，全局-main结束
};//自动调用满足先进后出。先析构那些新的